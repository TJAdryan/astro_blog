---
import BaseLayout from "../layouts/BaseLayout.astro";
import { getCollection } from "astro:content";

// 1. Fetch all blog posts
const posts = await getCollection("blog");

// 2. Sort posts by date in descending order
posts.sort((a, b) => b.data.pubDate.valueOf() - a.data.pubDate.valueOf());

// 3. Get the 3 most recent posts
const latestPosts = posts.slice(0, 3);
const housingPosts = posts.filter(post => post.data.tags && post.data.tags.includes('housing-simulation'));

// Remove the shuffle function and randomizedArticles assignment
---

<head>
  <!-- Force browsers to re-fetch favicon when you bump the version -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico?v=2" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2" />
  <!-- optional: mobile theme color -->
  <meta name="theme-color" content="#ffffff" />
  <!-- Add other common icons if you have them -->
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=2" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=2" />
</head>

<BaseLayout>
  <div class="container">
    <div class="hero-section">
      <h1 class="hero-title">
        <span class="primary-text">Next</span><span class="accent-text">Val</span><span class="primary-text">Data</span>
      </h1>
      <p class="hero-subtitle">
        Data insights, analytics, and technical explorations.
      </p>
    </div>

    <!-- Latest Posts Section -->
    {
      latestPosts.length > 1 && (
        <div class="latest-posts mb-12">
          <h2 class="text-2xl font-bold mb-4">Latest Posts</h2>
          <div class="flex flex-col gap-6 mt-4">
            {latestPosts.map(post => (
              <div class="border-b pb-4 last:border-b-0">
                <a
                  href={`/blog/${post.slug}/`}
                  class="text-xl font-bold text-blue-600 dark:text-blue-400 hover:underline"
                >
                  {post.data.title}
                </a>
                <p class="mt-2 text-gray-700 dark:text-gray-300">
                  {post.data.description}
                </p>
                <p class="text-sm text-gray-500 mt-1">
                  {new Date(post.data.pubDate).toLocaleDateString()}
                </p>
              </div>
            ))}
          </div>
          <div class="mt-6 text-center">
            <a href="/blog" class="inline-block px-6 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow hover:bg-blue-700 transition-colors">View All Blog Posts</a>
          </div>
        </div>
      )
    }

    <!-- Articles I am reading/have read Section -->
    <section id="all-articles" class="mb-12">
      <h2 class="text-2xl font-bold mb-4">Articles I am reading/have read</h2>

      <!-- Use same block structure as blog posts for consistent styling -->
      <div id="articles-list" class="space-y-4">
        <!-- Articles will be rendered by client-side JS -->
      </div>

      <div class="mt-6 text-center">
        <a href="/interesting-articles/" class="inline-block px-6 py-2 bg-blue-600 text-white rounded-lg font-semibold shadow hover:bg-blue-700 transition-colors">
          View All Articles
        </a>
      </div>
    </section>
  </div>
</BaseLayout>

<script is:inline>
  // Ensure shuffling happens on every page load and after DOM is ready
  document.addEventListener('DOMContentLoaded', function() {
    fetch('/data/articles.json')
      .then(res => res.json())
      .then(articles => {
        function shuffle(array) {
          let arr = array.slice();
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
          return arr;
        }

        // show 3 random articles on main page
        const shuffled = shuffle(articles).slice(0, 3);
        const container = document.getElementById('articles-list');
        if (container) {
          container.innerHTML = '';
          shuffled.forEach(article => {
            const wrapper = document.createElement('div');
            wrapper.className = 'border-b pb-4 last:border-b-0';

            // Title (styled like blog post titles)
            const a = document.createElement('a');
            a.href = article.url;
            a.target = '_blank';
            a.rel = 'noopener';
            a.className = 'text-xl font-bold text-blue-600 dark:text-blue-400 hover:underline';
            a.textContent = article.title;
            wrapper.appendChild(a);

            // Optional description / author line
            if (article.description) {
              const pDesc = document.createElement('p');
              pDesc.className = 'mt-2 text-gray-700 dark:text-gray-300';
              pDesc.textContent = article.description;
              wrapper.appendChild(pDesc);
            } else if (article.author) {
              const pAuthor = document.createElement('p');
              pAuthor.className = 'mt-2 text-gray-700 dark:text-gray-300';
              pAuthor.textContent = article.author;
              wrapper.appendChild(pAuthor);
            }

            // Meta line (area / journal etc.)
            const meta = document.createElement('p');
            meta.className = 'text-sm text-gray-500 mt-1';
            const areaText = article.area ? ` — ${article.area}` : '';
            // If article has authors/year/journal fields (from featuredArticles), prefer them
            if (article.authors || article.year || article.journal) {
              const authors = article.authors ? article.authors : '';
              const year = article.year ? ` (${article.year})` : '';
              const journal = article.journal ? ` - ${article.journal}` : '';
              meta.textContent = `${authors}${year}${journal}`;
            } else {
              meta.textContent = areaText.trim() ? areaText.substring(3) : ''; // remove leading " — " if present
            }
            if (meta.textContent) wrapper.appendChild(meta);

            container.appendChild(wrapper);
          });
        }
      });
  });

  // Force browser to reload favicon(s) at runtime and clear service worker / caches if present.
  (function refreshFavicons() {
    function addOrUpdateLink(rel, type, href) {
      // Remove existing links that match rel+type to avoid duplicates
      document.querySelectorAll(`link[rel="${rel}"][type="${type}"]`).forEach(el => el.remove());
      const link = document.createElement('link');
      link.rel = rel;
      link.type = type;
      link.href = href;
      document.head.appendChild(link);
    }

    // List of favicon paths to refresh (keep these in sync with files in /public)
    const favicons = [
      { rel: 'icon', type: 'image/x-icon', path: '/favicon.ico' },
      { rel: 'icon', type: 'image/png', path: '/favicon-32x32.png' },
      { rel: 'icon', type: 'image/png', path: '/favicon-16x16.png' },
      { rel: 'apple-touch-icon', type: 'image/png', path: '/apple-touch-icon.png' }
    ];

    // Append a timestamp query param to force re-fetch
    const stamp = `?v=${Date.now()}`;
    favicons.forEach(f => {
      // Only add the tag if the file likely exists (no network check here)
      addOrUpdateLink(f.rel, f.type, `${f.path}${stamp}`);
    });

    // Remove older favicon links without query params (optional cleanup)
    document.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"], link[rel="apple-touch-icon"]').forEach(l => {
      if (!l.href.includes('?v=')) l.remove();
    });

    // If a service worker is active it may be serving cached assets; try to unregister it and clear caches.
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(regs => {
        regs.forEach(reg => reg.unregister());
      }).catch(() => {/* ignore */});
    }
    if (window.caches && window.caches.keys) {
      caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k)))).catch(() => {/* ignore */});
    }
  })();
</script>

<style>
  .hero-section {
    text-align: center;
    padding: 3rem 0 4rem 0;
    background: linear-gradient(135deg, rgba(255, 107, 53, 0.05) 0%, rgba(255, 107, 53, 0.02) 50%, transparent 100%);
    border-radius: 16px;
    margin-bottom: 3rem;
  }

  .hero-title {
    font-size: clamp(3rem, 8vw, 6rem);
    font-weight: 900;
    letter-spacing: -0.02em;
    margin-bottom: 1.5rem;
    background: linear-gradient(135deg, #333 0%, #666 50%, #333 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }

  .accent-text {
    background: linear-gradient(135deg, var(--accent) 0%, #ff8c42 100%);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    position: relative;
  }

  .accent-text::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 4px;
    background: linear-gradient(135deg, var(--accent) 0%, #ff8c42 100%);
    border-radius: 2px;
    opacity: 0.7;
  }

  .hero-subtitle {
    font-size: clamp(1.125rem, 3vw, 1.5rem);
    color: rgba(102, 102, 102, 0.9);
    font-weight: 400;
    max-width: 600px;
    margin: 0 auto;
    line-height: 1.6;
  }

  .primary-text {
    transition: all 0.3s ease;
  }

  .hero-title:hover .primary-text {
    transform: translateY(-2px) scale(1.06);
    /* Only scale and move, keep gradient and clarity */
  }

  .hero-title:hover .accent-text {
    transform: translateY(-1px) scale(1.06);
    transition: all 0.3s ease;
  }

  @media (max-width: 768px) {
    .hero-section {
      padding: 2rem 1rem 3rem 1rem;
    }
    
    .hero-title {
      letter-spacing: -0.01em;
    }
  }

  /* New: ensure Twitter / X icon uses the site accent color */
  /* targets anchors linking to twitter.com or x.com and their SVGs */
  a[href*="twitter.com"],
  a[href*="x.com"] {
    color: var(--accent, #ff8c42);
  }

  /* Apply accent to SVG icons (fill + stroke). Use specificity to override utility classes if needed */
  a[href*="twitter.com"] svg,
  a[href*="x.com"] svg,
  a[href*="twitter.com"] .icon,
  a[href*="x.com"] .icon {
    fill: currentColor !important;
    stroke: currentColor !important;
  }
</style>